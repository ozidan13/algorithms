# Week 3: Quicksort, Hash Tables, and Graphs

This week explores more advanced algorithms and data structures that form the foundation of many complex applications. You'll learn about efficient sorting with Quicksort, key-value storage with hash tables, and graph representations and traversals.

## Topics Covered

1. Quicksort Algorithm and Analysis
2. Hash Tables and Hash Functions
3. Collision Resolution Strategies
4. Graph Representation (Adjacency Lists/Matrices)
5. Breadth-First Search (BFS)
6. Depth-First Search (DFS)

## Implementations


- `quicksort_visualization.html` - Interactive visualization of the quicksort algorithm
  - Time Complexity: O(n log n) average case, O(nÂ²) worst case
  - Space Complexity: O(log n)
  - Features: Animated pivot selection, partitioning visualization, performance comparison with other sorting algorithms

- `hash_table.html` - Implementation and visualization of hash tables
  - Time Complexity: O(1) average for insert/search/delete, O(n) worst case
  - Space Complexity: O(n)
  - Features: Interactive hash function demonstration, collision resolution visualization, load factor analysis

- `graph_representation.html` - Visual comparison of graph representation methods
  - Features: Interactive creation of graphs, conversion between adjacency lists and matrices, space/time complexity analysis

- `graph_traversal.html` - Visualization of graph traversal algorithms
  - Time Complexity: O(V + E) for both BFS and DFS
  - Space Complexity: O(V)
  - Features: Step-by-step traversal animation, path highlighting, queue/stack visualization for BFS/DFS

## Learning Objectives

By the end of this week, you should be able to:

1. Implement and analyze the quicksort algorithm
2. Design effective hash functions and understand collision resolution
3. Represent graphs using different data structures
4. Apply BFS and DFS to solve graph problems
5. Analyze the time and space complexity of graph algorithms

## Exercises

1. Implement quicksort with different pivot selection strategies
2. Create a hash table with chaining for collision resolution
3. Implement a graph using both adjacency list and adjacency matrix
4. Solve the shortest path problem using BFS
5. Detect cycles in a graph using DFS

## Additional Resources

- [Visualizing Quicksort](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)
- [Hash Tables Explained](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/)
- [Graph Theory Basics](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs)
- [Interactive Graph Algorithms](https://visualgo.net/en/dfsbfs)