{
  "promotional": [
    {
      "id": "promo_1",
      "message": "üéâ Welcome to the Algorithms & Data Structures course! Ready to begin your journey?",
      "type": "welcome",
      "duration": 5000
    },
    {
      "id": "promo_2",
      "message": "üìö New content available in Week 2! Explore linked lists and memory management.",
      "type": "update",
      "duration": 4000
    },
    {
      "id": "promo_3",
      "message": "üí° Did you know? Understanding algorithms can improve your problem-solving skills by 10x!",
      "type": "info",
      "duration": 4500
    }
  ],
  "motivational": [
    {
      "id": "motiv_1",
      "message": "üåü Great progress! You're mastering algorithms one step at a time.",
      "type": "progress",
      "duration": 4000
    },
    {
      "id": "motiv_2",
      "message": "üéØ Keep going! Each algorithm you learn brings you closer to becoming a better programmer.",
      "type": "encouragement",
      "duration": 4500
    },
    {
      "id": "motiv_3",
      "message": "‚≠ê You're doing great! Remember, every expert was once a beginner.",
      "type": "encouragement",
      "duration": 4000
    }
  ],
  "weeks": {
    "week1": {
      "intro": {
        "id": "w1_intro",
        "message": "üìä Week 1: Introduction to Algorithms - Learn the fundamental concepts that power modern computing!",
        "type": "info",
        "duration": 5000
      },
      "binary_search": {
        "id": "w1_binary",
        "message": "üîç Binary Search: Did you know this algorithm can find an item in a sorted list of a million items in just 20 steps?",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Try different array sizes to see how binary search scales logarithmically",
          "Notice how the search space is halved with each step",
          "Binary search only works on sorted arrays!"
        ]
      },
      "big_o": {
        "id": "w1_bigo",
        "message": "‚è±Ô∏è Big O Notation: The language of algorithm efficiency. O(1) is constant time, O(n) is linear time.",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Focus on the dominant term in complex expressions",
          "Space complexity is just as important as time complexity",
          "O(log n) algorithms are highly efficient for large datasets"
        ]
      },
      "selection_sort": {
        "id": "w1_selection",
        "message": "üîÑ Selection Sort: Simple but inefficient with O(n¬≤) time complexity. Great for understanding sorting fundamentals!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Watch how the sorted portion grows with each iteration",
          "Compare with other sorting algorithms to see efficiency differences",
          "Selection sort performs the same number of steps regardless of initial order"
        ]
      },
      "recursion": {
        "id": "w1_recursion",
        "message": "üîÅ Recursion: A function that calls itself! The key is having a base case to prevent infinite loops.",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Every recursive solution needs at least one base case",
          "Visualize the call stack to understand recursion depth",
          "Some problems are naturally recursive, like tree traversals"
        ]
      }
    },
    "week2": {
      "intro": {
        "id": "w2_intro",
        "message": "üß© Week 2: Arrays, Linked Lists, and Recursion - Explore the building blocks of data structures!",
        "type": "info",
        "duration": 5000
      },
      "array_operations": {
        "id": "w2_arrays",
        "message": "üìä Arrays: Fast access but slow insertion/deletion. Perfect when you need random access to elements!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Array access is O(1), but insertion can be O(n)",
          "Dynamic arrays automatically resize when they get full",
          "Arrays store elements in contiguous memory locations"
        ]
      },
      "linked_list": {
        "id": "w2_linkedlist",
        "message": "üîó Linked Lists: Fast insertion/deletion but slow access. Great when your list changes frequently!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Linked lists excel at insertions and deletions",
          "Doubly-linked lists allow traversal in both directions",
          "No wasted space, but extra memory for pointers"
        ]
      },
      "recursive_divide_conquer": {
        "id": "w2_divide",
        "message": "‚úÇÔ∏è Divide & Conquer: Break a problem into smaller sub-problems, solve them, and combine the results!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Merge sort is a classic divide and conquer algorithm",
          "The recursive approach often leads to elegant solutions",
          "Many efficient algorithms use this paradigm"
        ]
      },
      "memory_visualization": {
        "id": "w2_memory",
        "message": "üíæ Memory Management: Understanding how data structures use memory is crucial for efficient programming!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Stack memory is used for function calls and local variables",
          "Heap memory is used for dynamically allocated objects",
          "Memory fragmentation can impact performance"
        ]
      }
    },
    "week3": {
      "intro": {
        "id": "w3_intro",
        "message": "üåê Week 3: Quicksort, Hash Tables, and Graphs - Powerful algorithms for complex problems!",
        "type": "info",
        "duration": 5000
      },
      "quicksort": {
        "id": "w3_quicksort",
        "message": "‚ö° Quicksort: One of the fastest sorting algorithms with average O(n log n) time complexity!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Pivot selection greatly affects performance",
          "Quicksort is often faster in practice than other O(n log n) sorts",
          "The worst case is O(n¬≤), but rarely occurs with good pivot selection"
        ]
      },
      "hash_table": {
        "id": "w3_hash",
        "message": "üîë Hash Tables: Lightning-fast lookups, insertions, and deletions in average O(1) time!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Good hash functions distribute keys evenly",
          "Collision resolution is crucial for performance",
          "Used in databases, caches, and symbol tables"
        ]
      },
      "graph_representation": {
        "id": "w3_graphrep",
        "message": "üìä Graph Representation: Adjacency matrices are fast for dense graphs, adjacency lists for sparse ones!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Adjacency matrices use O(V¬≤) space",
          "Adjacency lists use O(V+E) space",
          "Choose based on graph density and operations needed"
        ]
      },
      "graph_traversal": {
        "id": "w3_graphtraversal",
        "message": "üîç Graph Traversal: BFS finds shortest paths, DFS explores as far as possible before backtracking!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "BFS uses a queue, DFS uses a stack (or recursion)",
          "BFS is great for finding shortest paths in unweighted graphs",
          "DFS is often simpler to implement recursively"
        ]
      }
    },
    "week4": {
      "intro": {
        "id": "w4_intro",
        "message": "üß† Week 4: Advanced Algorithms - Greedy methods, Dynamic Programming, and Machine Learning!",
        "type": "info",
        "duration": 5000
      },
      "greedy_algorithms": {
        "id": "w4_greedy",
        "message": "ü§ë Greedy Algorithms: Make locally optimal choices at each step to find a global optimum!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "Greedy algorithms don't always find the optimal solution",
          "They're usually simpler and more efficient than alternatives",
          "Examples include Dijkstra's algorithm and Huffman coding"
        ]
      },
      "dynamic_programming": {
        "id": "w4_dp",
        "message": "üß© Dynamic Programming: Solve complex problems by breaking them down into simpler subproblems!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "DP combines recursion with memoization",
          "Bottom-up approaches often use tabulation",
          "Great for optimization problems with overlapping subproblems"
        ]
      },
      "knapsack_problem": {
        "id": "w4_knapsack",
        "message": "üéí Knapsack Problem: A classic optimization problem solved efficiently with dynamic programming!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "The greedy approach doesn't work for the 0/1 knapsack",
          "DP solution has O(nW) time complexity",
          "Real applications include resource allocation and budgeting"
        ]
      },
      "knn_classifier": {
        "id": "w4_knn",
        "message": "ü§ñ K-Nearest Neighbors: A simple but powerful machine learning algorithm for classification!",
        "type": "tip",
        "duration": 5000,
        "tips": [
          "The value of K affects the decision boundary smoothness",
          "Distance metrics matter - try Euclidean, Manhattan, etc.",
          "KNN is a lazy learner - it doesn't build a model during training"
        ]
      }
    }
  }
}