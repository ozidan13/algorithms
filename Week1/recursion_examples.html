<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recursion Examples</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="../css/global-algo.css">
  <style>
    .visualization {
      border: 1px solid var(--border-color);
      border-radius: var(--card-radius);
      padding: 15px;
      margin-top: 20px;
      min-height: 150px;
      position: relative;
      background-color: var(--background-alt);
      transition: var(--theme-transition);
    }
    .call-tree {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-family: 'SF Mono', Monaco, Consolas, 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .call-node {
      padding: 5px 10px;
      background-color: var(--secondary-text);
      color: var(--background-main);
      border-radius: 6px;
      margin: 3px 0;
      transition: all 0.3s ease;
      white-space: nowrap;
    }
    .call-node.active {
      background-color: var(--color-high);
      color: white;
      transform: scale(1.05);
      font-weight: bold;
    }
    .call-node.completed {
      background-color: var(--color-found);
      color: white;
    }
    .call-node.base {
        background-color: var(--color-low);
        color: white;
    }
    .call-node.memo {
        background-color: var(--color-mid);
        color: white;
        font-style: italic;
    }
    .call-node[style*="margin-left"] {
        position: relative;
    }
    .call-node[style*="margin-left"]:not(:first-child)::before {
        content: '';
        position: absolute;
        left: -10px;
        top: 50%;
        width: 10px;
        height: 1px;
        background-color: var(--border-color);
    }
  </style>
</head>
<body data-theme="dark">
  <a href="../index.html#week1" id="back-button" class="btn"><i class="fas fa-arrow-left"></i> Back</a>

  <h1><i class="fas fa-redo icon-margin"></i>Recursion Examples</h1>
  
  <!-- Introduction -->
  <div class="container">
    <h2><i class="fas fa-info-circle icon-margin"></i>What is Recursion?</h2>
    <div class="explanation">
      <p>Recursion is a programming technique where a function calls itself to solve a problem. It consists of:</p>
      <ol>
        <li><strong>Base case:</strong> The condition that stops the recursion</li>
        <li><strong>Recursive case:</strong> The function calling itself with a simpler version of the problem</li>
      </ol>
      <p>Recursion is particularly useful for problems that can be broken down into smaller, similar subproblems.</p>
    </div>
  </div>
  
  <!-- Factorial Example -->
  <div class="container">
    <h2><i class="fas fa-calculator icon-margin"></i>Factorial Example</h2>
    <div class="example-container">
      <p>The factorial of a non-negative integer <strong>n</strong> is the product of all positive integers less than or equal to <strong>n</strong>. For example: 5! = 5 × 4 × 3 × 2 × 1 = 120</p>
      <div class="code-container">
        <pre><code>function factorial(n) {
  if (n === 0 || n === 1) return 1;
  return n * factorial(n - 1);
}</code></pre>
      </div>
      <div class="controls">
        <label for="factorial-input">Enter a number:</label>
        <input type="number" id="factorial-input" min="0" max="15" value="5">
        <button id="factorial-btn"><i class="fas fa-play icon-margin"></i>Calculate Factorial</button>
        <button id="factorial-step-btn"><i class="fas fa-step-forward icon-margin"></i>Step Through</button>
      </div>
      <div class="result" id="factorial-result">Result will appear here.</div>
      <div class="step-controls">
        <button id="factorial-prev-btn" disabled><i class="fas fa-backward icon-margin"></i>Previous Step</button>
        <button id="factorial-next-btn" disabled><i class="fas fa-forward icon-margin"></i>Next Step</button>
      </div>
      <div class="visualization" id="factorial-visualization">
        <div class="call-tree" id="factorial-tree">Call stack visualization will appear here.</div>
      </div>
      <div class="log" id="factorial-log"><p>Logs will appear here.</p></div>
    </div>
  </div>
  
  <!-- Fibonacci Example -->
  <div class="container">
    <h2><i class="fas fa-project-diagram icon-margin"></i>Fibonacci Sequence Example</h2>
    <div class="example-container">
      <p>The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. For example: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</p>
      <div class="code-container">
        <pre><code>function fibonacci(n) {
  if (n === 0) return 0;
  if (n === 1) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
      </div>
      <div class="controls">
        <label for="fibonacci-input">Enter a position:</label>
        <input type="number" id="fibonacci-input" min="0" max="10" value="6">
        <button id="fibonacci-btn"><i class="fas fa-play icon-margin"></i>Calculate Fibonacci</button>
        <button id="fibonacci-step-btn"><i class="fas fa-step-forward icon-margin"></i>Step Through</button>
      </div>
      <div class="result" id="fibonacci-result">Result will appear here.</div>
      <div class="step-controls">
        <button id="fibonacci-prev-btn" disabled><i class="fas fa-backward icon-margin"></i>Previous Step</button>
        <button id="fibonacci-next-btn" disabled><i class="fas fa-forward icon-margin"></i>Next Step</button>
      </div>
      <div class="visualization" id="fibonacci-visualization">
        <div class="call-tree" id="fibonacci-tree">Call stack visualization will appear here.</div>
      </div>
      <div class="log" id="fibonacci-log"><p>Logs will appear here.</p></div>
    </div>
  </div>
  
  <!-- Recursive Countdown Example -->
  <div class="container">
    <h2><i class="fas fa-sort-numeric-down icon-margin"></i>Recursive Countdown Example</h2>
    <div class="example-container">
      <p>A simple countdown function that demonstrates recursion by counting down from a given number to 1.</p>
      <div class="code-container">
        <pre><code>function countdown(n) {
  if (n <= 0) return;
  console.log(n);
  countdown(n - 1);
}</code></pre>
      </div>
      <div class="controls">
        <label for="countdown-input">Start from:</label>
        <input type="number" id="countdown-input" min="1" max="15" value="5">
        <button id="countdown-btn"><i class="fas fa-play icon-margin"></i>Start Countdown</button>
        <button id="countdown-step-btn"><i class="fas fa-step-forward icon-margin"></i>Step Through</button>
      </div>
      <div class="result" id="countdown-result">Countdown sequence will appear here.</div>
      <div class="step-controls">
        <button id="countdown-prev-btn" disabled><i class="fas fa-backward icon-margin"></i>Previous Step</button>
        <button id="countdown-next-btn" disabled><i class="fas fa-forward icon-margin"></i>Next Step</button>
      </div>
      <div class="visualization" id="countdown-visualization">
        <div class="call-tree" id="countdown-tree">Call stack visualization will appear here.</div>
      </div>
      <div class="log" id="countdown-log"><p>Logs will appear here.</p></div>
    </div>
  </div>
  
  <script>
    // Theme persistence
    const savedTheme = localStorage.getItem('theme') || 'dark';
    document.body.setAttribute('data-theme', savedTheme);

    // General log function
    function logMessage(logElement, message, type = 'info') {
        const p = document.createElement('p');
        p.textContent = message;
        p.classList.add(`log-${type}`);
        logElement.prepend(p);
        while (logElement.children.length > 20) {
            logElement.removeChild(logElement.lastChild);
        }
    }

    /* ===================== Factorial Example Script ===================== */
    (function() {
      const factorialInput = document.getElementById('factorial-input');
      const factorialBtn = document.getElementById('factorial-btn');
      const factorialStepBtn = document.getElementById('factorial-step-btn');
      const factorialResult = document.getElementById('factorial-result');
      const factorialPrevBtn = document.getElementById('factorial-prev-btn');
      const factorialNextBtn = document.getElementById('factorial-next-btn');
      const factorialTree = document.getElementById('factorial-tree');
      const factorialLog = document.getElementById('factorial-log');
      
      let factorialSteps = [];
      let factorialCurrentStep = -1;
      
      factorialBtn.addEventListener('click', () => {
        const n = parseInt(factorialInput.value);
        if (isNaN(n) || n < 0 || n > 15) {
          factorialResult.textContent = 'Please enter a number between 0 and 15.';
          return;
        }
        factorialLog.innerHTML = '';
        factorialTree.innerHTML = '';
        logMessage(factorialLog, `Calculating factorial(${n})...`, 'info');
        const result = factorial(n);
        factorialResult.textContent = `${n}! = ${result}`;
        logMessage(factorialLog, `Final result: ${result}`, 'success');
      });
      
      factorialStepBtn.addEventListener('click', () => {
        const n = parseInt(factorialInput.value);
        if (isNaN(n) || n < 0 || n > 15) {
          factorialResult.textContent = 'Please enter a number between 0 and 15.';
          return;
        }
        factorialSteps = [];
        factorialLog.innerHTML = '<p>Starting step-through...</p>';
        factorialTree.innerHTML = '';
        generateFactorialSteps(n);
        factorialCurrentStep = 0;
        factorialPrevBtn.disabled = true;
        factorialNextBtn.disabled = factorialSteps.length <= 1;
        showFactorialStep();
      });
      
      factorialPrevBtn.addEventListener('click', () => {
        if (factorialCurrentStep > 0) {
          factorialCurrentStep--;
          showFactorialStep();
        }
      });
      
      factorialNextBtn.addEventListener('click', () => {
        if (factorialCurrentStep < factorialSteps.length - 1) {
          factorialCurrentStep++;
          showFactorialStep();
        }
      });
      
      function factorial(n) {
        if (n === 0 || n === 1) return 1;
        return n * factorial(n - 1);
      }
      
      function generateFactorialSteps(n) {
        factorialSteps = [];
        generateFactorialStepsRecursive(n);
      }
      
      function generateFactorialStepsRecursive(n, depth = 0, callId = `f-${Date.now()}-${Math.random()}`) {
        const currentCallId = `${callId}-${n}`;
        factorialSteps.push({
          type: 'call',
          n: n,
          depth: depth,
          callId: currentCallId,
          message: `Calling factorial(${n})`
        });
        let result;
        if (n === 0 || n === 1) {
          result = 1;
          factorialSteps.push({
            type: 'base',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: result,
            message: `Base case: factorial(${n}) returns 1`
          });
        } else {
          const subResult = generateFactorialStepsRecursive(n - 1, depth + 1, currentCallId);
          result = n * subResult;
          factorialSteps.push({
            type: 'return',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: result,
            message: `factorial(${n}) returns ${n} * ${subResult} = ${result}`
          });
        }
        return result;
      }
      
      function showFactorialStep() {
        if (factorialCurrentStep < 0 || factorialCurrentStep >= factorialSteps.length) return;
        const step = factorialSteps[factorialCurrentStep];
        factorialTree.innerHTML = '';
        const activeNodes = new Set();
        let tempDepth = -1;
        let parentCallId = null;
        for (let i = 0; i <= factorialCurrentStep; i++) {
            const s = factorialSteps[i];
            if (s.type === 'call') {
                activeNodes.add(s.callId);
            } else if (s.type === 'base' || s.type === 'return') {
                activeNodes.delete(s.callId);
            }
        }

        let currentDepthMap = {};
        factorialSteps.slice(0, factorialCurrentStep + 1).forEach((s, idx) => {
            const node = document.createElement('div');
            node.className = 'call-node';
            node.style.marginLeft = `${s.depth * 30}px`;

            if (s.type === 'call') {
                node.textContent = `factorial(${s.n}) calling...`;
                if (activeNodes.has(s.callId) && idx === factorialCurrentStep) {
                    node.classList.add('active');
                }
            } else if (s.type === 'base') {
                node.textContent = `factorial(${s.n}) -> ${s.result} (base)`;
                node.classList.add('base');
                if (idx === factorialCurrentStep) node.classList.add('active');
            } else if (s.type === 'return') {
                node.textContent = `factorial(${s.n}) -> ${s.result}`;
                node.classList.add('completed');
                 if (idx === factorialCurrentStep) node.classList.add('active');
            }
            factorialTree.appendChild(node);
        });

        let logType = 'info';
        if (step.type === 'base') logType = 'success';
        if (step.type === 'return') logType = 'success';
        logMessage(factorialLog, `Step ${factorialCurrentStep + 1}: ${step.message}`, logType);

        if (factorialCurrentStep === factorialSteps.length - 1 && (step.type === 'return' || step.type === 'base')) {
          factorialResult.textContent = `Final result: ${step.result}`;
        } else {
            factorialResult.textContent = 'Stepping through...';
        }
        factorialPrevBtn.disabled = factorialCurrentStep <= 0;
        factorialNextBtn.disabled = factorialCurrentStep >= factorialSteps.length - 1;
      }
    })();
    
    /* ===================== Fibonacci Example Script ===================== */
    (function() {
      const fibonacciInput = document.getElementById('fibonacci-input');
      const fibonacciBtn = document.getElementById('fibonacci-btn');
      const fibonacciStepBtn = document.getElementById('fibonacci-step-btn');
      const fibonacciResult = document.getElementById('fibonacci-result');
      const fibonacciPrevBtn = document.getElementById('fibonacci-prev-btn');
      const fibonacciNextBtn = document.getElementById('fibonacci-next-btn');
      const fibonacciTree = document.getElementById('fibonacci-tree');
      const fibonacciLog = document.getElementById('fibonacci-log');
      
      let fibonacciSteps = [];
      let fibonacciCurrentStep = -1;
      let fibonacciMemoization = {};
      
      fibonacciBtn.addEventListener('click', () => {
        const n = parseInt(fibonacciInput.value);
        if (isNaN(n) || n < 0 || n > 10) {
          fibonacciResult.textContent = 'Please enter a number between 0 and 10.';
          return;
        }
        fibonacciLog.innerHTML = '';
        fibonacciTree.innerHTML = '';
        logMessage(fibonacciLog, `Calculating fibonacci(${n})...`, 'info');
        const result = fibonacci(n);
        fibonacciResult.textContent = `fibonacci(${n}) = ${result}`;
        logMessage(fibonacciLog, `Final result: ${result}`, 'success');
      });
      
      fibonacciStepBtn.addEventListener('click', () => {
        const n = parseInt(fibonacciInput.value);
        if (isNaN(n) || n < 0 || n > 10) {
          fibonacciResult.textContent = 'Please enter a number between 0 and 10.';
          return;
        }
        fibonacciSteps = [];
        fibonacciLog.innerHTML = '<p>Starting step-through...</p>';
        fibonacciTree.innerHTML = '';
        fibonacciMemoization = {};
        generateFibonacciSteps(n);
        fibonacciCurrentStep = 0;
        fibonacciPrevBtn.disabled = true;
        fibonacciNextBtn.disabled = fibonacciSteps.length <= 1;
        showFibonacciStep();
      });
      
      fibonacciPrevBtn.addEventListener('click', () => {
        if (fibonacciCurrentStep > 0) {
          fibonacciCurrentStep--;
          showFibonacciStep();
        }
      });
      
      fibonacciNextBtn.addEventListener('click', () => {
        if (fibonacciCurrentStep < fibonacciSteps.length - 1) {
          fibonacciCurrentStep++;
          showFibonacciStep();
        }
      });
      
      function fibonacci(n) {
        if (n === 0) return 0;
        if (n === 1) return 1;
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
      
      function generateFibonacciSteps(n) {
        fibonacciSteps = [];
        fibonacciMemoization = {};
        generateFibonacciStepsRecursive(n);
      }
      
      function generateFibonacciStepsRecursive(n, depth = 0, callId = `fib-${Date.now()}-${Math.random()}`) {
        const currentCallId = `${callId}-${n}`;
        if (fibonacciMemoization[n] !== undefined) {
          fibonacciSteps.push({
            type: 'memo',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: fibonacciMemoization[n],
            message: `Memoized: fibonacci(${n}) = ${fibonacciMemoization[n]}`
          });
          return fibonacciMemoization[n];
        }
        fibonacciSteps.push({
          type: 'call',
          n: n,
          depth: depth,
          callId: currentCallId,
          message: `Calling fibonacci(${n})`
        });
        let result;
        if (n === 0) {
          result = 0;
          fibonacciSteps.push({
            type: 'base',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: result,
            message: `Base case: fibonacci(0) returns 0`
          });
        } else if (n === 1) {
          result = 1;
          fibonacciSteps.push({
            type: 'base',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: result,
            message: `Base case: fibonacci(1) returns 1`
          });
        } else {
          const subResult1 = generateFibonacciStepsRecursive(n - 1, depth + 1, currentCallId + '- L');
          const subResult2 = generateFibonacciStepsRecursive(n - 2, depth + 1, currentCallId + '- R');
          result = subResult1 + subResult2;
          fibonacciSteps.push({
            type: 'return',
            n: n,
            depth: depth,
            callId: currentCallId,
            result: result,
            message: `fibonacci(${n}) returns ${subResult1} + ${subResult2} = ${result}`
          });
        }
        fibonacciMemoization[n] = result;
        return result;
      }
      
      function showFibonacciStep() {
        if (fibonacciCurrentStep < 0 || fibonacciCurrentStep >= fibonacciSteps.length) return;
        const step = fibonacciSteps[fibonacciCurrentStep];
        fibonacciTree.innerHTML = '';
        const activeNodes = new Set();
        for (let i = 0; i <= fibonacciCurrentStep; i++) {
            const s = fibonacciSteps[i];
            if (s.type === 'call') {
                activeNodes.add(s.callId);
            } else if (s.type === 'base' || s.type === 'return' || s.type === 'memo') {
                activeNodes.delete(s.callId);
            }
        }

        fibonacciSteps.slice(0, fibonacciCurrentStep + 1).forEach((s, idx) => {
            const node = document.createElement('div');
            node.className = 'call-node';
            node.style.marginLeft = `${s.depth * 30}px`;

            if (s.type === 'call') {
                 node.textContent = `fib(${s.n}) calling...`;
                 if (activeNodes.has(s.callId) && idx === fibonacciCurrentStep) {
                    node.classList.add('active');
                 }
            } else if (s.type === 'base') {
                node.textContent = `fib(${s.n}) -> ${s.result} (base)`;
                node.classList.add('base');
                 if (idx === fibonacciCurrentStep) node.classList.add('active');
            } else if (s.type === 'return') {
                node.textContent = `fib(${s.n}) -> ${s.result}`;
                node.classList.add('completed');
                 if (idx === fibonacciCurrentStep) node.classList.add('active');
            } else if (s.type === 'memo') {
                node.textContent = `fib(${s.n}) -> ${s.result} (memo)`;
                node.classList.add('memo');
                 if (idx === fibonacciCurrentStep) node.classList.add('active');
            }
            fibonacciTree.appendChild(node);
        });

        let logType = 'info';
        if (step.type === 'base') logType = 'success';
        if (step.type === 'return') logType = 'success';
        if (step.type === 'memo') logType = 'info';
        logMessage(fibonacciLog, `Step ${fibonacciCurrentStep + 1}: ${step.message}`, logType);

        if (fibonacciCurrentStep === fibonacciSteps.length - 1 && (step.type === 'return' || step.type === 'base' || step.type === 'memo')) {
          fibonacciResult.textContent = `Final result: ${step.result}`;
        } else {
             fibonacciResult.textContent = 'Stepping through...';
        }
        fibonacciPrevBtn.disabled = fibonacciCurrentStep <= 0;
        fibonacciNextBtn.disabled = fibonacciCurrentStep >= fibonacciSteps.length - 1;
      }
    })();
    
    /* ===================== Countdown Example Script ===================== */
    (function() {
      const countdownInput = document.getElementById('countdown-input');
      const countdownBtn = document.getElementById('countdown-btn');
      const countdownStepBtn = document.getElementById('countdown-step-btn');
      const countdownResult = document.getElementById('countdown-result');
      const countdownPrevBtn = document.getElementById('countdown-prev-btn');
      const countdownNextBtn = document.getElementById('countdown-next-btn');
      const countdownTree = document.getElementById('countdown-tree');
      const countdownLog = document.getElementById('countdown-log');
      
      let countdownSteps = [];
      let countdownCurrentStep = -1;
      
      countdownBtn.addEventListener('click', () => {
        const n = parseInt(countdownInput.value);
        if (isNaN(n) || n < 1 || n > 15) {
          countdownResult.textContent = 'Please enter a number between 1 and 15.';
          return;
        }
        countdownResult.textContent = '';
        countdownTree.innerHTML = '';
        countdownLog.innerHTML = '';
        logMessage(countdownLog, `Starting countdown from ${n}...`, 'info');
        const numbers = [];
        for (let i = n; i >= 1; i--) {
          numbers.push(i);
          logMessage(countdownLog, `Output: ${i}`, 'info');
          const node = document.createElement('div');
          node.className = 'call-node completed';
          node.textContent = i;
          node.style.marginLeft = `${(n - i) * 10}px`;
          countdownTree.appendChild(node);
        }
        countdownResult.textContent = `Countdown sequence: ${numbers.join(', ')}`;
        logMessage(countdownLog, 'Countdown finished.', 'success');
      });
      
      countdownStepBtn.addEventListener('click', () => {
        const n = parseInt(countdownInput.value);
        if (isNaN(n) || n < 1 || n > 15) {
          countdownResult.textContent = 'Please enter a number between 1 and 15.';
          return;
        }
        countdownSteps = [];
        countdownLog.innerHTML = '<p>Starting step-through...</p>';
        countdownTree.innerHTML = '';
        generateCountdownSteps(n);
        countdownCurrentStep = 0;
        countdownPrevBtn.disabled = true;
        countdownNextBtn.disabled = countdownSteps.length <= 1;
        showCountdownStep();
      });
      
      countdownPrevBtn.addEventListener('click', () => {
        if (countdownCurrentStep > 0) {
          countdownCurrentStep--;
          showCountdownStep();
        }
      });
      
      countdownNextBtn.addEventListener('click', () => {
        if (countdownCurrentStep < countdownSteps.length - 1) {
          countdownCurrentStep++;
          showCountdownStep();
        }
      });
      
      function generateCountdownSteps(n) {
        countdownSteps = [];
        generateCountdownStepsRecursive(n);
      }
      
      function generateCountdownStepsRecursive(n, depth = 0, callId = `cd-${Date.now()}-${Math.random()}`) {
         const currentCallId = `${callId}-${n}`;
        countdownSteps.push({
          type: 'call',
          n: n,
          depth: depth,
          callId: currentCallId,
          message: `Calling countdown(${n})`
        });
        if (n <= 0) {
          countdownSteps.push({
            type: 'base',
            n: n,
            depth: depth,
            callId: currentCallId,
            message: `Base case: countdown(${n}) reached. Stop.`
          });
          return;
        }
        countdownSteps.push({
          type: 'log',
          n: n,
          depth: depth,
          callId: currentCallId,
          message: `Output: ${n}`
        });
        generateCountdownStepsRecursive(n - 1, depth + 1, currentCallId);
        countdownSteps.push({
          type: 'return',
          n: n,
          depth: depth,
          callId: currentCallId,
          message: `Return from countdown(${n})`
        });
      }
      
      function showCountdownStep() {
        if (countdownCurrentStep < 0 || countdownCurrentStep >= countdownSteps.length) return;
        const step = countdownSteps[countdownCurrentStep];
        countdownTree.innerHTML = '';
        const loggedNumbers = [];

        const activeNodes = new Set();
        for (let i = 0; i <= countdownCurrentStep; i++) {
            const s = countdownSteps[i];
            if (s.type === 'call') {
                activeNodes.add(s.callId);
            } else if (s.type === 'base' || s.type === 'return') {
                activeNodes.delete(s.callId);
            }
        }

        countdownSteps.slice(0, countdownCurrentStep + 1).forEach((s, idx) => {
            const node = document.createElement('div');
            node.className = 'call-node';
            node.style.marginLeft = `${s.depth * 30}px`;

            if (s.type === 'call') {
                 node.textContent = `countdown(${s.n}) calling...`;
                 if (activeNodes.has(s.callId) && idx === countdownCurrentStep) {
                    node.classList.add('active');
                 }
            } else if (s.type === 'log') {
                node.textContent = `Output: ${s.n}`;
                node.classList.add('completed');
                if (idx === countdownCurrentStep) node.classList.add('active');
                loggedNumbers.push(s.n);
            } else if (s.type === 'base') {
                node.textContent = `countdown(${s.n}) base case`;
                node.classList.add('base');
                 if (idx === countdownCurrentStep) node.classList.add('active');
            } else if (s.type === 'return') {
                node.textContent = `countdown(${s.n}) returning`;
                 if (idx === countdownCurrentStep) node.classList.add('active');
            }
            countdownTree.appendChild(node);
        });

        let logType = 'info';
        if (step.type === 'log') logType = 'success';
        if (step.type === 'base') logType = 'info';
        logMessage(countdownLog, `Step ${countdownCurrentStep + 1}: ${step.message}`, logType);

        if (loggedNumbers.length > 0) {
          countdownResult.textContent = `Current sequence: ${loggedNumbers.join(', ')}`;
        } else {
            countdownResult.textContent = 'Stepping through...';
        }

        if (countdownCurrentStep === countdownSteps.length - 1) {
            if (loggedNumbers.length > 0) {
                countdownResult.textContent = `Final sequence: ${loggedNumbers.join(', ')}`;
            } else {
                 countdownResult.textContent = 'Countdown finished.';
            }
        }

        countdownPrevBtn.disabled = countdownCurrentStep <= 0;
        countdownNextBtn.disabled = countdownCurrentStep >= countdownSteps.length - 1;
      }
    })();
  </script>
</body>
</html>
